import json # Importing the JSON file that has all the Nodes, Edges, Weights (The Winter Region (map))
import heapq  # Importing heapq gor priority queue
import matplotlib.pyplot as plt # Importing matplotlib for visual graphs
import matplotlib.colors as mcolors
import numpy as np
from matplotlib.animation import FuncAnimation
import math
import random
import networkx as nx
import itertools
import os # Colours
os.system("")

# ===== COLORS =====
RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"



covered_edges = set()

# I am creating a class for the Nodes
class Node:
    def __init__(self, name, x=0, y=0):
        self.name = name       # Node Name
        self.edges = []        # Making a list to store all the Edges connected to the Node
        self.x = x             # X coordinate for visualization of the map
        self.y = y             # Y coordinate for visualization of the map

# I am creating a class for the Edges
class Edge:
    def __init__(self, from_node, to_node, weight):
        self.from_node = from_node    # Start Node
        self.to_node = to_node        # End Node
        self.weight = weight          # Weight of the road
        self.used = False             # Tracking if edge has been traversed

# I am creating a class for the Graph
class Graph:
    def __init__(self):
        self.nodes = {}
        self.edges= []        #List of all Edges

    def add_node(self, name):
        if name not in self.nodes:         # No Duplicates
            self.nodes[name] = Node(name)

    def add_edge(self, u, v, weight):

          # New Edge between nodes u and v with given weight
        if not any((e.from_node.name == v and e.to_node.name == u) or
                   (e.from_node.name == u and e.to_node.name == v) for e in self.edges):
            
            #Check if edge already exists
            edge = Edge(self.nodes[u], self.nodes[v], weight)
            self.edges.append(edge)
            self.nodes[u].edges.append(edge)
            self.nodes[v].edges.append(edge)


def edge_id(u, v):
    return tuple(sorted((u, v)))

# I am using Dijkstra Function for shortest path
def dijkstra(graph, start, end):

    # This part Initializes distances
    distances = {node_name: float('inf') for node_name in graph.nodes}  # Start every Node to infinity
    distances[start] = 0  # Distance to itself

    # These are the Previous nodes
    previous = {node_name: None for node_name in graph.nodes}

    # Priority queue 
    pq = [(0, start)]

    
    # While there are Nodes left in the queue
    while pq:
        current_dist, current_node = heapq.heappop(pq) # I am Popping from priority queue

        if current_dist > distances[current_node]: # Skipping if already explored
            continue

        # Explore neighbor nodes of the nodes that is currently popped
        for edge in graph.nodes[current_node].edges:
            neighbor = edge.to_node.name if edge.from_node.name == current_node else edge.from_node.name # Determine neighbor Node (the other end of the edge)
            distance = current_dist + edge.weight # Calculate the distance to the neighbor Node

            # If this new distance is better update
            if distance < distances[neighbor]:
                distances[neighbor] = distance # Shortest distance so far
                previous[neighbor] = current_node # Previous Node which came from current Node
                heapq.heappush(pq, (distance, neighbor)) # Push Neighbor into the  priority queue

    # Reconstruct path
    path = []
    node = end
    while node:
        path.insert(0, node)
        node = previous[node]

    return distances[end], path # Returns values (total grit cost and ordered list of nodes(path))



# Function (Finds which Nodes have an odd number of roads connected to them)  ---> for CPP loop later
def get_odds(graph):
    odd_nodes = [] # Empty List to collect the Nodes
    for node_name, node in graph.nodes.items(): # Check every Node in the graph
        if len(node.edges) % 2 != 0:   # Checks if a Node's degree is odd
            odd_nodes.append(node_name)  # If Node's degree is odd then add to the list
    return odd_nodes # Return full List




# Function (modifies graph to make it Eurelian)
def duplicate_edges(graph, matching):

    for u, v in matching:  #Loop: For every u,v in matching  list
        
        _, path = dijkstra(graph, u, v)  # Find the shortest path between u and v

        # For each consecutive pair of nodes in the path, add a duplicate edge
        for i in range(len(path) - 1):
            node_a = path[i]
            node_b = path[i + 1]

            # Find the original edge between node_a and node_b
            for edge in graph.edges:
                if ((edge.from_node.name == node_a and edge.to_node.name == node_b) or
                    (edge.from_node.name == node_b and edge.to_node.name == node_a)):
                    
                    # Duplicate the edge (add another Edge object)
                    new_edge = Edge(edge.from_node, edge.to_node, edge.weight)
                    graph.edges.append(new_edge)
                    edge.from_node.edges.append(new_edge)
                    edge.to_node.edges.append(new_edge)
                    break  # only duplicate 1 edge per pair


# Function to find the best way to pair odd Nodes (minimum-weight matching)
def minimum_matching(graph, odd_nodes):
    complete_graph = nx.Graph() # Create empty graph using NetworkX
    for i in range(len(odd_nodes)):  # Loop through all pairs of oodd nodes
        for j in range(i + 1, len(odd_nodes)):
            u = odd_nodes[i]
            v = odd_nodes[j]
            dist, _ = dijkstra(graph, u, v) # Find shortest path between the 2 Nodes using Dijkstra's function from earlier 
            complete_graph.add_edge(u, v, weight=dist) # Add edge to the complete graph
    return list(nx.algorithms.matching.min_weight_matching(complete_graph)) # Finds best way to pair odd Nodes



# Function to find the CPP Circuit
def find_cpp(graph, start_node):
    circuit = [] # Final result
    stack = [start_node]  # nodes we’re exploring

    while stack: # Loop: While we have still something to explore
        current = stack[-1]  # The current node
        unused_edges = [e for e in graph.nodes[current].edges if not e.used]  # paths from  this node that haven't been taken yet

        # If there are any unused edges left
        if unused_edges:  

            edge = unused_edges[0] # Check first unused edge
            edge.used = True  # mark it as used

            # Move to the next node
            next_node = edge.to_node.name if edge.from_node.name == current else edge.from_node.name
            stack.append(next_node) # Push the edge on the task
        else:
            
            circuit.append(stack.pop()) # Dead end, no edges left -> add to the circuit[]

    
    return circuit[::-1] # Reverse the circuit order to get the real path order


# Openning the JSON file (the Map)
with open("data/road.json") as f:
    data = json.load(f)


# Create an empty graph
g = Graph()

# Add nodes
for node_data in data["area"]["nodes"]:
    g.add_node(node_data["node"])
    g.nodes[node_data["node"]].x = node_data["x-coord"]
    g.nodes[node_data["node"]].y = node_data["y-coord"]

# Add edges
for node_data in data["area"]["nodes"]:
    u = node_data["node"]
    for link in node_data["links"]:
        for v, weight in link.items():
            g.add_edge(u, v, int(weight))  # convert weight from string to int



# Reset all edges
def reset_edge(graph):
    
    for edge in graph.edges:
        edge.used = False


# Visual: Map for option 1 (shortest path)
def show_path(graph, path):
    plt.figure(figsize=(12, 8)) # Board width and height

    # Draw all edges normally (gray)
    for edge in graph.edges:
        x_values = [edge.from_node.x, edge.to_node.x]
        y_values = [edge.from_node.y, edge.to_node.y]
        plt.plot(x_values, y_values, 'gray', linewidth=1, zorder=1)

    # Draw the shortest path in RED with arrows
    for i in range(len(path) - 1):
        u = path[i]
        v = path[i + 1]

        x1 = graph.nodes[u].x
        y1 = graph.nodes[u].y
        x2 = graph.nodes[v].x
        y2 = graph.nodes[v].y

        # Red line (visualised path)
        plt.plot([x1, x2], [y1, y2], color='red', linewidth=3, zorder=3)

        # Arrows
        plt.annotate(
            "",
            xy=(x2, y2),
            xytext=(x1, y1),
            arrowprops=dict(arrowstyle="->", color="red", lw=2),
            zorder=4
        )

    # Draw nodes
    for node_name, node in graph.nodes.items():
        plt.scatter(node.x, node.y, color='blue', s=100, zorder=5)
        plt.text(node.x + 0.1, node.y + 0.1, node_name,
                 fontsize=10, zorder=6)

    plt.title("WinterRegion Map - Shortest Path")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()

# Function, Visual: shows the map along with the CPP Circuit path 
def show_cpp(graph, circuit):
    plt.figure(figsize=(12, 8))

    # Draw base map in gray
    for edge in graph.edges:
        x1, y1 = edge.from_node.x, edge.from_node.y
        x2, y2 = edge.to_node.x, edge.to_node.y
        plt.plot([x1, x2], [y1, y2], "gray", linewidth=0.5, zorder=1)

    # Create gradient colors
    cmap = mcolors.LinearSegmentedColormap.from_list("", ["green", "yellow", "red"])
    steps = len(circuit) - 1
    colors = [cmap(i / steps) for i in range(steps)]

    # Track how many times each edge is used
    usage = {}

    def edge_key(a, b):
        return tuple(sorted((a, b)))   # so A→B and B→A are the same edge

    # Draw CPP circuit with arrows, gradient and duplicates
    for i in range(steps):
        u = circuit[i]
        v = circuit[i+1]

        node_u = graph.nodes[u]
        node_v = graph.nodes[v]

        x1, y1 = node_u.x, node_u.y
        x2, y2 = node_v.x, node_v.y

        # edge usage count
        ek = edge_key(u, v)
        usage[ek] = usage.get(ek, 0) + 1
        count = usage[ek]

        # Compute perpendicular offset for duplicated traversals
        dx = x2 - x1
        dy = y2 - y1
        length = math.sqrt(dx*dx + dy*dy)
        if length == 0:
            length = 1  # avoid division by zero

        # unit perpendicular vector
        ox = -dy / length
        oy = dx / length

        # each duplicate gets nudged further
        offset_scale = 0.06 * (count - 1)
        offx = ox * offset_scale
        offy = oy * offset_scale

        # Color for this segment
        c = colors[i]

        # Dashed if this is a duplicate
        linestyle = "-" if count == 1 else "--"

        # Draw the segment (with offset)
        plt.plot(
            [x1 + offx, x2 + offx],
            [y1 + offy, y2 + offy],
            color=c,
            linewidth=2.5,
            linestyle=linestyle,
            zorder=4
        )

        # Draw arrow (same color)
        plt.annotate(
            "",
            xy=(x2 + offx, y2 + offy),
            xytext=(x1 + offx, y1 + offy),
            arrowprops=dict(arrowstyle="->", color=c, lw=2),
            zorder=5
        )

        # Step number label (slightly offset)
        mid_x = (x1 + x2) / 2 + offx * 0.4
        mid_y = (y1 + y2) / 2 + offy * 0.4

        plt.text(
            mid_x, mid_y,
            str(i + 1),
            fontsize=9,
            color="Black",
            weight="bold",
            zorder=6
        )

    # Draw nodes on top
    for name, node in graph.nodes.items():
        plt.scatter(node.x, node.y, color="blue", s=100, zorder=10)
        plt.text(node.x + 0.12, node.y + 0.12, name, fontsize=10, zorder=11)

    plt.title("CPP Circuit Visualization")
    plt.grid(True, linestyle="--", alpha=0.5)
    plt.show()


# Function Show CPP Map with animations.
def animate_cpp(graph, circuit):
    fig, ax = plt.subplots(figsize=(12, 8))

    # Draw base map 
    for edge in graph.edges:
        x = [edge.from_node.x, edge.to_node.x]
        y = [edge.from_node.y, edge.to_node.y]
        ax.plot(x, y, 'lightgray', linewidth=1)

    # Draw nodes
    for name, node in graph.nodes.items():
        ax.scatter(node.x, node.y, color='blue', s=80, zorder=5)
        ax.text(node.x + 0.1, node.y + 0.1, name,
                fontsize=10, weight="bold")

    # Animated Line
    animated_lines = []

    def update(i):
        if i == 0:
            return

        u = circuit[i - 1]
        v = circuit[i]

        x1 = graph.nodes[u].x
        y1 = graph.nodes[u].y
        x2 = graph.nodes[v].x
        y2 = graph.nodes[v].y

        # Draw i with gradient color
        cmap = plt.cm.get_cmap("plasma")
        color = cmap(i / len(circuit))

        line = ax.plot([x1, x2], [y1, y2],
                       color=color,
                       linewidth=3,
                       zorder=4)[0]

        # Draw arrow
        ax.annotate(
            "",
            xy=(x2, y2),
            xytext=(x1, y1),
            arrowprops=dict(arrowstyle="->", lw=1.5, color=color),
            zorder=5
        )

        # Steps 
        mid_x = (x1 + x2) / 2
        mid_y = (y1 + y2) / 2
        ax.text(mid_x + 0.12, mid_y + 0.12,
                str(i),
                fontsize=10,
                color="black",
                weight="bold",
                zorder=6)

        animated_lines.append(line)

    anim = FuncAnimation(fig, update, frames=len(circuit), interval=500, repeat=False)

    plt.title("CPP Circuit — Animated")
    plt.grid(True, linestyle="--", alpha=0.5)
    plt.show()


#Function, Visual: Option 3 (show the map)
def show_map(graph):
    plt.figure(figsize=(12, 8))
    plt.gca().set_facecolor("#f5f5f5")

    # Draw edges + grit
    for edge in graph.edges:
        x_values = [edge.from_node.x, edge.to_node.x] 
        y_values = [edge.from_node.y, edge.to_node.y]
        plt.plot(x_values, y_values, 'gray', zorder=1)

        # Midpoint of edge
        mid_x = (edge.from_node.x + edge.to_node.x) / 2
        mid_y = (edge.from_node.y + edge.to_node.y) / 2

        # Grit label (distance)
        plt.text(mid_x - 0.1, mid_y + 0.05, str(edge.weight), fontsize=10, color='darkred', zorder=4)

    # Draw nodes
    for node_name, node in graph.nodes.items():
        plt.scatter(node.x, node.y, color='blue', s=50, edgecolor="black", linewidth=1.5,  zorder=2)
        plt.text(node.x + 0.1, node.y + 0.1, node_name, fontsize=10, zorder=3)

    plt.title("WinterRegion Map")
    plt.xlabel("X-coordinate")
    plt.ylabel("Y-coordinate")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()


# Function: Input validation (checks if the input is correct and prompts the user to try again if the input is Invalid)
def input_validation(graph, prompt):
    while True:
        node = input(prompt).strip().upper()

        if len(node) == 1 and node.isalpha() and node in graph.nodes:
            return node
        
        print(f"{RED}Invalid node. Please enter a letter A-Z that exists on the map.{RESET}")


def number_validation(prompt, min_val, max_val):
    while True:
        try:
            value = int(input(prompt))
            if min_val <= value <= max_val:
                return value
            else:
                print(f"Error: Enter a number between {min_val} and {max_val}")
        except ValueError:
            print("Error: Input must be a number")


# Main Menu for easier navigation 
def main():
    while True:

        print(f"\n{RESET}{BOLD}-------- |MENU| --------{RESET}")
        print(f"{BLUE}[1] Find shortest path {RESET} ")
        print(f"{GREEN}[2] Show Chinese Postman Problem {RESET} ")
        print(f"{MAGENTA}[3] Show the Map {RESET} ")
        print(f"{CYAN}[] Notes & Instructions {RESET}")
        print(f"{RED}[4] Exit {RESET} ")
        
        choice = input("Select option 1 - 6: ") # Users choice (only numbers 1 - 6)

        # Option 1: Shortest Path
        if choice == "1":
            print("Nice, you selected option:", choice)

            start_node = input_validation(g,"Enter START node: ") # Input Starting Node
            end_node = input_validation(g, "Enter END node: ")  # Input Ending Node

            dist, path = dijkstra(g, start_node, end_node) # Get shortest path from dijkstra function

            print("\nShortest path:", " -> ".join(path))
            print("Total grit:", dist)

            show_path(g, path) # Show the map with navigation arrows (visual)

        
        # Option 2: Chinese Postman Problem
        elif choice == "2":
            print("Nice, you selected option:", choice)
            start_node = input_validation(g, "Enter START node for Chinese Postman Problem: ") # Input Starting Node (only letters that exist in the map A-Z)

            odd_nodes = get_odds(g) # Get odd Nodes
            matching = minimum_matching(g, odd_nodes)

            duplicate_edges(g, matching) # Get duplicate Edges for the CPP circuit 

            circuit = find_cpp(g, start_node) # Get Chinese Postman Problem result
            total_grit = sum(edge.weight for edge in g.edges) # Get the total grit
            odd_after = get_odds(g) # Get odd nodes after duplication

            print("\nCPP Circuit (full route):")
            print(" -> ".join(circuit))
            print("Total grit including duplicates:", total_grit)

            
            
            # Submenu for extra info about the CPP Circuit
            while True:
                print(f"\n{BOLD}-------- | EXTRA INFO | --------{RESET}")
                print(f"{BLUE}[1] Show odd-degree nodes BEFORE duplication{RESET}")
                print(f"{MAGENTA}[2] Show matching pairs + odd-degree nodes AFTER duplication{RESET}")
                print(f"{YELLOW}[3] Classic Map{RESET}")
                print(f"{GREEN}[4] Animated Map{RESET}")
                print(f"{RED}[5] Go back to main menu")

                sub_choice = input(f"{RESET}Select option 1 - 5: ") # Input a number (only 1-3)

                # Choice 1: Show Odd-degree nodes before duplication
                if sub_choice == "1":
                    print("\nOdd-degree nodes BEFORE duplication:")
                    print(", ".join(odd_nodes))

                # Choice 2: Show pairs selected to duplicate edges and after duplication
                elif sub_choice == "2":
                    print("\nPairs selected to duplicate:")
                    for u, v in matching:
                        print(f"{u} <-> {v}")

                    print("\nOdd-degree nodes AFTER duplication:") 
                    if len(odd_after) == 0:
                        print("None — graph is set!")
                    else:
                        print(", ".join(odd_after))

                # Choice 3: See CPP Map       
                elif sub_choice =="3":
                    show_cpp(g, circuit)   # static

                # Choice 4: See animated CPP Map
                elif sub_choice =="4":
                    animate_cpp(g, circuit)        # new animation

                # Choice 5: Exit sub-menu
                elif sub_choice == "5":
                    print("Returning to main menu...")
                    break

                # Every other input except numbers 1-5 is considered Invalid
                else:
                    print(f"{RED} Invalid choice. Please enter a number 1-5")


        

        # Option 4: Show the Map            
        elif choice == "3":
           print("Displaying the map...")
           show_map(g)

        # Option 6: Exit
        elif choice == "4":
            print("Thank you for using this program. Goodbye!")
            break

        # Every other input except numbers 1-5 is considered Invalid
        else:
            print(f"{RED} Invalid choice. Please enter a number 1-5.")


main()

    





